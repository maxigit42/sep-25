minishell/
â”œâ”€â”€ Makefile
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ parser/
â”‚   â”‚   â”œâ”€â”€ tokenizer.c
â”‚   â”‚   â”œâ”€â”€ parser.c
â”‚   â”œâ”€â”€ executor/
â”‚   â”‚   â”œâ”€â”€ exec.c
â”‚   â”‚   â”œâ”€â”€ pipes.c
â”‚   â”‚   â”œâ”€â”€ redir.c
â”‚   â”œâ”€â”€ builtins/
â”‚   â”‚   â”œâ”€â”€ cd.c
â”‚   â”‚   â”œâ”€â”€ echo.c
â”‚   â”‚   â”œâ”€â”€ env.c
â”‚   â”œâ”€â”€ signals/
â”‚   â”‚   â”œâ”€â”€ signals.c
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ env_utils.c
â”‚       â”œâ”€â”€ string_utils.c
â””â”€â”€ include/
    â”œâ”€â”€ minishell.h
    â”œâ”€â”€ parser.h
    â”œâ”€â”€ executor.h




ğŸ§± ETAPA 1: Fundamentos del proyecto
âœ… Objetivos principales
Ejecutar comandos como una shell (ls, pwd, etc.)

Soportar redirecciones (>, >>, <)

Soportar pipes (|)

Implementar algunos builtins (cd, echo, exit, env, export, unset, pwd)  //pendiente

Manejar seÃ±ales (Ctrl+C, Ctrl+D, etc.)

Manejar comillas ('', "") //pendinete

Manejar variables de entorno ($HOME, etc.) //pendiente

Implementar expansiÃ³n de variables ($VAR) // nose que es

Manejar heredoc (<<) // tampoco

ğŸ§  ETAPA 2: RevisiÃ³n de conocimientos necesarios
ğŸ”§ Sistema y C
fork(), execve(), wait(), pipe(), dup2(), open(), close(), access()

signal(), kill(), readline, termios

Manejo de memoria (malloc, free)

Estructuras de datos (listas, tablas hash, Ã¡rboles opcional)

ğŸ“š LibrerÃ­as Ãºtiles
readline para input del usuario

libft (si estÃ¡s en 42, probablemente la necesitas)

errno para manejo de errores

ğŸš§ ETAPA 3: Plan de desarrollo
1. ğŸ—ï¸ Infraestructura bÃ¡sica
âœ… Crear el bucle principal (loop del shell)

âœ… Leer input (readline)

âœ… AÃ±adir historial

âœ… Manejar Ctrl+D (EOF), Ctrl+C (SIGINT)

2. ğŸ“œ Parsing de comandos
âœ… Tokenizar comandos (espacios, comillas, |, >, >>, <, <<)

âœ… Manejar comillas ('', "")

âœ… Expandir variables ($VAR, $?)

âœ… Eliminar espacios innecesarios

âœ… Detectar errores de sintaxis

3. ğŸ”„ EjecuciÃ³n
âœ… Ejecutar comandos externos con fork() y execve()

âœ… Buscar binarios en PATH

âœ… Diferenciar comandos built-in vs externos

4. âš™ï¸ Built-ins
Implementa como funciones internas:

echo

cd

pwd

export

unset

env

exit

5. ğŸ“¡ Pipes y redirecciones
âœ… Manejar | (pipes)

âœ… Redirecciones de entrada y salida:

> â†’ sobrescribir

>> â†’ aÃ±adir al final

< â†’ input de archivo

<< â†’ heredoc

6. ğŸ“¶ SeÃ±ales
âœ… Capturar SIGINT (Ctrl+C), SIGQUIT (Ctrl+)

âœ… Configurar seÃ±ales en padre/hijo (ej. no duplicar prints)

âœ… Manejar Ctrl+D para salir limpiamente

ğŸ§ª ETAPA 4: Testing
ğŸ” Casos de prueba comunes
Comillas mezcladas: echo "hola 'mundo'", echo 'hola $USER'

Heredoc con seÃ±ales (Ctrl+C)

Variables no definidas

Redirecciones encadenadas

Comandos encadenados con mÃºltiples pipes

Comando con error de sintaxis (cat | | ls)


__________________________________________________________________________________________________


âš ï¸ Reglas clave para no perder puntos
Variable global para seÃ±ales:

Solo puedes tener una variable global tipo volatile sig_atomic_t g_signal = 0;

Ãšsala solo para decir â€œrecibÃ­ SIGINTâ€ o similar. Nada mÃ¡s.

Todo lo demÃ¡s, pÃ¡salo con pipes o mecanismos seguros.

No quotes mal cerradas:

Si el usuario pone: echo "Hola â†’ debes detectar error y no ejecutar.

Igual con 'Hola o echo $PATH |.

No interpretar barra invertida \ o punto y coma ;

No debes soportar: echo hola\ mundo ni echo hola ; ls â†’ ignÃ³ralos o muestra error de sintaxis.

No hagas built-ins avanzados

Solo implementa lo mÃ­nimo obligatorio: no hagas cd -, export -p, etc.

No uses funciones no autorizadas

Solo las de la lista (mÃ¡s tu libft).

Por ejemplo: no uses system(), strtok(), ni getline().

Semana	Objetivo
DÃ­a 1â€“5	Entrada + seÃ±ales + Makefile âœ”ï¸
DÃ­a 6â€“10	Parsing bÃ¡sico del input
DÃ­a 11â€“15	Implementar execve y procesos hijos
DÃ­a 16â€“20	Pipes
DÃ­a 21â€“25	Redirecciones (>, >>, <, <<)
DÃ­a 26â€“30	Variables de entorno y expansiÃ³n ($, $?)
DÃ­a 31â€“35	Built-ins (cd, pwd, export, etc.)
DÃ­a 36â€“40	Heredoc y control de errores
DÃ­a 41â€“45	SeÃ±ales en hijos y edge cases
DÃ­a 46â€“50	Testing, limpieza, norminette, leaks
" 

Minishell (proceso padre)
    â”œâ”€â”€ Prompt: "minishell$ "
    â”œâ”€â”€ Entrada: "ls"
    â”œâ”€â”€ fork()
    â”‚      â”œâ”€â”€ Proceso hijo: ejecuta execve("/bin/ls")
    â”‚      â””â”€â”€ Padre: espera al hijo con waitpid()
    â”œâ”€â”€ Cuando el hijo termina â†’ Prompt otra vez
    â””â”€â”€ Se repite...


Minishell (proceso principal)
â”‚
â”œâ”€â”€ Bucle principal:
â”‚     â”œâ”€â”€ Mostrar el prompt (por ejemplo, "minishell$ ")
â”‚     â”œâ”€â”€ Leer entrada del usuario (readline)
â”‚     â”œâ”€â”€ Si la entrada es vacÃ­a o EOF (Ctrl+D) â†’ salir
â”‚     â”œâ”€â”€ Tokenizar y parsear la entrada
â”‚     â”œâ”€â”€ Si es un comando interno:
â”‚     â”‚      â””â”€â”€ Ejecutar directamente (sin fork)
â”‚     â””â”€â”€ Si es un comando externo:
â”‚            â”œâ”€â”€ fork()
â”‚            â”‚     â”œâ”€â”€ [Proceso hijo]:
â”‚            â”‚     â”‚       â””â”€â”€ execve() para ejecutar el comando
â”‚            â”‚     â””â”€â”€ [Proceso padre]:
â”‚            â”‚             â””â”€â”€ Esperar al hijo con waitpid()
â”‚            â””â”€â”€ Liberar memoria y volver al prompt
â”‚
â””â”€â”€ (Repetir el bucle)

ğŸ› ï¸ Esquema con funciones principales (modularizado)

t_minishell_loop()
â”‚
â”œâ”€â”€ mostrar_prompt()
â”œâ”€â”€ input = leer_linea_usuario()
â”œâ”€â”€ if (input vacÃ­o o NULL) salir
â”œâ”€â”€ lista_tokens = parsear(input)
â”œâ”€â”€ if (comando interno):
â”‚      â””â”€â”€ ejecutar_builtin(lista_tokens)
â””â”€â”€ else:
       â””â”€â”€ ejecutar_comando_externo(lista_tokens)

ejecutar_comando_externo():
    â”œâ”€â”€ fork()
    â”‚     â”œâ”€â”€ [hijo]:
    â”‚     â”‚      â””â”€â”€ execve()
    â”‚     â””â”€â”€ [padre]:
    â”‚            â””â”€â”€ waitpid()
    â””â”€â”€ liberar memoria

ğŸ” Â¿DÃ³nde usar procesos hijos?

    Comandos externos: Ejecutar siempre en un hijo (fork + execve).

    Comandos internos (cd, exit, export, etc.): Ejecutar en el proceso padre (porque alteran el entorno del shell y no tienen binario).

ğŸ“Š Visual aÃºn mÃ¡s resumido

[MiniShell Proceso Principal]
     â”‚
     â””â”€â”€ Bucle:
           â”œâ”€â”€ Mostrar prompt
           â”œâ”€â”€ Leer comando
           â”œâ”€â”€ Parsear tokens
           â”œâ”€â”€ if Builtin:
           â”‚       â””â”€â”€ Ejecutar
           â””â”€â”€ else:
                   â”œâ”€â”€ fork()
                   â”‚     â””â”€â”€ Hijo: execve()
                   â””â”€â”€ Padre: waitpid()
           â””â”€â”€ Repetir

âš ï¸ Consejo importante

Primero, asegÃºrate de tener claro el bucle principal y el mecanismo fork/execve. DespuÃ©s puedes agregar:

    Pipes.

    Redirecciones.

    Variables de entorno.

    Expansiones.

    Control de seÃ±ales.