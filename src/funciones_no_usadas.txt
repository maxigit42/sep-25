// void	set_env_value(t_env **env, const char *key, const char *value)
// {
// 	t_env *curr = *env;

// 	while(curr)
// 	{
// 		if(ft_strcmp(curr->key, key) == 0)
// 		{
// 			free(curr->value);
// 			curr->value = ft_strdup(value);
// 			return ;
// 		}
// 		curr = curr->next;
// 	}
// 	t_env *new;
// 	new = malloc(sizeof(t_env));
// 	if(!new)
// 		return ;
// 	new->key = ft_strdup(key);
// 	if(value)
// 		new->value = ft_strdup(value);
// 	else
// 		new->value = ft_strdup("");
// 	new->next = NULL;
// 	if(!*env)
// 	{
// 		*env = new;
// 		return ;
// 	}
// 	curr = *env;
//     while (curr->next)
//         curr = curr->next;
//     curr->next = new;
// }

// char **env_list_to_array(t_env *env)
// {
//     int count = 0;
//     t_env *temp = env;
//     char **array;
//     int i;
// 	char *key_equal;

//     while (temp)
//     {
//         count++;
//         temp = temp->next;
//     }
//     array = malloc(sizeof(char *) * (count + 1));
//     if (!array)
//         return (NULL);
//     temp = env;
//     i = 0;
//     while (temp)
//     {
//         if (temp->value)
//         {
//             key_equal = ft_strjoin(temp->key, "=");
//             array[i] = ft_strjoin(key_equal, temp->value);
//             free(key_equal);
//         }
//         else
//         {
//             array[i] = ft_strjoin(temp->key, "=");
//         }
//         i++;
//         temp = temp->next;
//     }
//     array[i] = NULL;
//     return (array);
// }


// char	*expand_variables(char *str, t_data *data)
// {
// 	int		i;
// 	char	*result;
// 	char	*tmp;
// 	char	c[2];

// 	result = ft_strdup("");
// 	if (!result || !str)
// 		return (NULL);
// 	i = 0;
// 	while (str[i])
// 	{
// 		if (str[i] == '$' && str[i + 1] != '\0')
// 		{
// 			if (str[i + 1] == '?')
// 				i += handle_exit_status(data, &result);
// 			else
// 				i += handle_var(data, &result, &str[i + 1]);
// 			continue ;
// 		}
// 		c = { str[i], '\0' };
// 		tmp = ft_strjoin(result, c);
// 		free(result);
// 		result = tmp;
// 		i++;
// 	}
// 	return (result);
// }

// t_parse_token	*split_with_quotes(char *str)
// {
// 	t_parse_token	*tokens;
// 	int				count;
// 	int				i;
// 	int				j;
// 	int				len;

// 	count = count_tokens(str);
// 	tokens = malloc(sizeof(t_parse_token) * (count + 1));
// 	if (!tokens)
// 		return (NULL);
// 	i = 0;
// 	j = 0;
// 	while (str[i])
// 	{
// 		while (str[i] == ' ' || str[i] == '\t')
// 			i++;
// 		if (!str[i])
// 			break ;
// 		len = token_len(&str[i]);
// 		tokens[j].in_single_quote = (str[i] == '\'');
// 		tokens[j].in_double_quote = (str[i] == '"');
// 		tokens[j].str = extract_token(&str[i], len);
// 		i += len;
// 		j++;
// 	}
// 	tokens[j].str = NULL;
// 	return (tokens);
// }


// void	ft_take_cmd(t_data *data)
// {
// 	t_token	*current;
// 	int		i;
// 	int		j;
// 	char	**subcmd;
// 	int		arg_count;

// 	if (!data || !data->token)
// 		return ;

// 	data->cmd = malloc(sizeof(char **) * (data->pipe + 2));
// 	if (!data->cmd)
// 		return ;
// 	i = 0;
// 	current = data->token;

// 	while (current)
// 	{
// 		j = 0;
// 		arg_count = count_pipe_args(current);
// 		if (arg_count <= 0)
// 			arg_count = 1;
// 		subcmd = malloc(sizeof(char *) * (arg_count + 1));
// 		if (!subcmd)
// 			return (free_cmd_array(data->cmd), (void)(data->cmd = NULL));

// 		while (current && current->type != PIPE)
// 		{
// 			if (current->type == OUTFILE || current->type == INFILE
// 				|| current->type == APPEND || current->type == HEREDOC)
// 			{
// 				current = current->next;
// 				if (current)
// 					current = current->next;
// 				continue ;
// 			}
// 			subcmd[j++] = ft_strdup(current->str);
// 			current = current->next;
// 		}
// 		subcmd[j] = NULL;
// 		data->cmd[i++] = subcmd;

// 		if (current && current->type == PIPE)
// 			current = current->next;
// 	}
// 	data->cmd[i] = NULL;
// }